package me.zakharov

import com.badlogic.gdx.Gdx
import com.badlogic.gdx.graphics.*
import com.badlogic.gdx.graphics.g2d.Batch
import com.badlogic.gdx.graphics.glutils.FloatTextureData
import com.badlogic.gdx.graphics.glutils.ShaderProgram
import com.badlogic.gdx.math.MathUtils.lerp
import com.badlogic.gdx.scenes.scene2d.Actor
import me.apemanzilla.ktcl.CLCommandQueue
import me.apemanzilla.ktcl.CLContext
import me.apemanzilla.ktcl.cl10.*
import java.nio.ByteBuffer
data class PheromonesConfig(
    val alpha: Float = 0.95f, // in 1 sec
    val thres: Float = 0.01f
)
//enum PherType { none = 0, trail = 1, food_trail = -1, debug = -2 } ;
enum class PherType(val v: Float) {
    none(0f), trail(1f), food_trail(-1f), debug(-2f);

    companion object {
        fun clCode(): String =
            enumValues<PherType>().joinToString(
                separator = ", ",
                prefix = "//generated by host\nenum PherType { ",
                postfix = " };\n"
            ) {
                "%s = %.0f".format(it.name, it.v)
            }
    }
}
class Pheromones(
        ctx: CLContext,
        private val cmd: CLCommandQueue,
        w: Int,
        h: Int
) : Actor() {

    private val alpha: Float = 0.75f // in 1 sec
    private val thres: Float = 0.003f

    private val shaderProgram = ShaderProgram(
        Gdx.files.internal("shaders/pheromones.vert"),
        Gdx.files.internal("shaders/pheromones.frag")
    ).apply {
        if ( !isCompiled ) {error("shader compile failed: $log")}
    }

    fun reset(): Boolean {
        m.clear()
        return true
    }

    /// opencl stuff
    private val prog = ctx.createProgramWithSource( this::class.java.getResource("/kernels/decay.kernel").readText() )
            .also { it.build() }

    internal val m = createFloatMatrix2d(w, h)
    internal val shared = ctx.share(m.buff)

    private val kernel = prog.createKernel("decay_kernel").apply {
        setArg(1, thres)
        setArg(2, shared.remoteBuff)
        setArg(3, shared.remoteBuff)
    }
    /// end opencl stuff

    internal class WrappedFloatTextureData(w: Int, h: Int, private val buff: ByteBuffer)
        : FloatTextureData(w, h, GL30.GL_R32F, GL30.GL_RED, 0, false) {
        override fun consumeCustomData(target: Int) {
            Gdx.gl.glTexImage2D(target, 0, GL30.GL_R32F, width, height, 0, GL30.GL_RED, GL20.GL_FLOAT, buff)
        }
    }
    private val wrappedTexData = WrappedFloatTextureData(w, h, m.buff)
    private val glTex = Texture(wrappedTexData).apply {
        setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest)
    }

    override fun act(delta: Float) {
        with(kernel) {
            setArg(0, lerp(1f, alpha, delta))
        }

        shared.upload(cmd)

        cmd.enqueueNDRangeKernel(kernel, m.width*m.height.toLong())
        cmd.finish()

        shared.download(cmd)
        super.act(delta)
    }

    override fun draw(batch: Batch?, parentAlpha: Float) {
        super.draw(batch, parentAlpha)

        batch?.let { b ->
            b.shader = shaderProgram
            glTex.load(wrappedTexData)
            b.draw(glTex, 0f, 0f, stage.width, stage.height)
            b.shader = null
        }
    }

    fun print() {

        m.forEach { x, y, v ->
            if (x==0) println()
            when(v) {
                PherType.food_trail.v -> print("f")
                PherType.trail.v -> print("t")
                PherType.debug.v -> print("D")
                PherType.none.v -> print(" ")
            }
        }
    }

    fun requestRedraw() {
        //tex?.dispose()
        //tex = null
    }
}
